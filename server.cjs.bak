// Backup of server.cjs - created automatically before replacing with minimal read-only server
// Original contents preserved below.
// -----------------------------------------------------------------------------
// (backup content follows - original file snapshot)
// -----------------------------------------------------------------------------
// Minimal read-only server
// This server exposes only simple GET endpoints that fetch data from MongoDB.
// No authentication or write operations are provided here.

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');

require('dotenv').config();

const PORT = process.env.PORT || 5000;
const MONGO_URI = process.env.MONGO_URI || 'mongodb+srv://dariripay:s.a.2016%40S@pay.w8d4cp7.mongodb.net/?appName=pay';

const app = express();
app.use(cors());
app.use(express.json({ limit: '5mb' }));

// connect to MongoDB
mongoose.connect(MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
}).then(() => {
  console.log('âœ… MongoDB connected');
}).catch(err => {
  console.error('âŒ MongoDB connection error:', err && err.message ? err.message : err);
});

// Minimal schemas â€” keep flexible so any existing collections can be read
const ProductSchema = new mongoose.Schema({}, { strict: false, collection: 'products' });
const CategorySchema = new mongoose.Schema({}, { strict: false, collection: 'categories' });
const OrderSchema = new mongoose.Schema({}, { strict: false, collection: 'orders' });
const SettingSchema = new mongoose.Schema({}, { strict: false, collection: 'settings' });

const Product = mongoose.models.Product || mongoose.model('Product', ProductSchema);
const Category = mongoose.models.Category || mongoose.model('Category', CategorySchema);
const Order = mongoose.models.Order || mongoose.model('Order', OrderSchema);
const Setting = mongoose.models.Setting || mongoose.model('Setting', SettingSchema);

// Health
app.get('/api/health', async (req, res) => {
  const state = mongoose.connection.readyState; // 0 disconnected, 1 connected
  res.json({ ok: state === 1, mongoState: state });
});

// Read-only endpoints
app.get('/api/products', async (req, res) => {
  try {
    const products = await Product.find({}).lean().limit(1000);
    res.json(products);
  } catch (err) {
    console.error('GET /api/products error', err);
    res.status(500).json({ error: 'Failed to fetch products' });
  }
});

app.get('/api/categories', async (req, res) => {
  try {
    const categories = await Category.find({}).lean();
    res.json(categories);
  } catch (err) {
    console.error('GET /api/categories error', err);
    res.status(500).json({ error: 'Failed to fetch categories' });
  }
});

app.get('/api/orders', async (req, res) => {
  try {
    const orders = await Order.find({}).lean().limit(500);
    res.json(orders);
  } catch (err) {
    console.error('GET /api/orders error', err);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

// settings: return first settings document or empty object
app.get('/api/settings', async (req, res) => {
  try {
    const settings = await Setting.findOne({}).lean();
    res.json(settings || {});
  } catch (err) {
    console.error('GET /api/settings error', err);
    res.status(500).json({ error: 'Failed to fetch settings' });
  }
});

// static uploads (optional, read-only)
app.use('/uploads', express.static(path.join(__dirname, 'public', 'uploads')));

app.listen(PORT, () => {
  console.log(`âœ… Read-only server running on port ${PORT}`);
  console.log(`ğŸ“ Health: https://backendpay-1.onrender.com/api/health`);
});
// Backup of original server.cjs created before replacing with minimal read-only server
// Original content preserved for recovery. Do not edit this file.

/*
  Original server.cjs backup
  (truncated) Full original file saved in this backup.
  If you need to restore, rename this file to server.cjs and restart the server.
*/
